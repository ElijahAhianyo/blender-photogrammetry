# Visualsfm Extract

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
None
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-visualsfm.extract.extract-start--->
## [visualsfm.extract.extract](3-visualsfm_extract.md#visualsfm.extract.extract)

<!---Documatic-section-extract-start--->
<!---Documatic-block-visualsfm.extract.extract-start--->
<details>
	<summary><code>visualsfm.extract.extract</code> code snippet</summary>

```python
def extract(properties, *args, **kargs):
    filepath = bpy.path.abspath(properties.filepath)
    imagepaths = list(filter(None, bpy.path.abspath(properties.imagepath).split(';')))
    if not os.path.exists(filepath):
        if not filepath:
            raise AttributeError(f'VisualSfM filepath must be provided')
        raise AttributeError(f'Unable to locate VisualSfM file:\n"{filepath}"')
    with open(filepath, 'r') as f:
        lines = f.readlines()
    if len(lines) == 0 or not lines[0].startswith('NVM_V3'):
        raise Exception('Not a valid NVM file')
    cameras = {}
    trackers = {}
    data = {'trackers': trackers, 'cameras': cameras}
    total_cameras = int(lines[2])
    total_points = int(lines[4 + total_cameras])
    num = '-?\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?'
    camera_re = re.compile(f'^(?P<name>.*?)\\s+(?P<f>{num})\\s+(?P<QW>{num})\\s+(?P<QX>{num})\\s+(?P<QY>{num})\\s+(?P<QZ>{num})\\s+(?P<X>{num})\\s+(?P<Y>{num})\\s+(?P<Z>{num})\\s+(?P<k1>{num})\\s+{num}\\s*$')
    for i in range(int(total_cameras)):
        match = camera_re.match(lines[3 + i])
        if not match:
            raise Exception(f'Camera {i} did not match the format specification')
        filenames = [fp for fp in [os.path.join(*parts) for parts in zip(imagepaths, [match.group('name')] * len(imagepaths))] if os.path.exists(fp)]
        if not filenames:
            if properties.subdirs:
                for imagepath in imagepaths:
                    for (root, dirs, files) in os.walk(imagepath):
                        if match.group('name') in files:
                            filenames = [os.path.join(root, match.group('name'))]
            if not filenames:
                raise AttributeError(f'''VisualSfM image not found for camera {i}:\n"{match.group('name')}""''')
        q = Quaternion(tuple(map(float, [match.group('QW'), match.group('QX'), match.group('QY'), match.group('QZ')])))
        '\n        https://github.com/SBCV/Blender-Addon-Photogrammetry-Importer/blob/75189215dffde50dad106144111a48f29b1fed32/photogrammetry_importer/file_handler/nvm_file_handler.py#L55\n        VisualSFM CAMERA coordinate system is the standard CAMERA coordinate system in computer vision (not the same\n        as in computer graphics like in bundler, blender, etc.)\n        That means\n              the y axis in the image is pointing downwards (not upwards)\n              the camera is looking along the positive z axis (points in front of the camera show a positive z value)\n        The camera coordinate system in computer vision VISUALSFM uses camera matrices,\n        which are rotated around the x axis by 180 degree\n        i.e. the y and z axis of the CAMERA MATRICES are inverted\n        '
        R = q.to_matrix()
        R.rotate(Euler((pi, 0, 0)))
        R.transpose()
        c = Vector(tuple(map(float, [match.group('X'), match.group('Y'), match.group('Z')])))
        t = -1 * R @ c
        R.transpose()
        cameras.setdefault(i, {'filename': filenames[0], 'f': float(match.group('f')), 'k': (float(match.group('k1')), 0, 0), 't': tuple(t), 'R': tuple(map(tuple, tuple(R))), 'trackers': {}})
        if 'resolution' not in data:
            data.setdefault('resolution', get_image_size(filenames[0]))
    marker_re = re.compile(f'^(?P<X>{num})\\s+(?P<Y>{num})\\s+(?P<Z>{num})\\s+(?P<R>\\d+)\\s+(?P<G>\\d+)\\s+(?P<B>\\d+)\\s+(?P<num_measurements>{num})\\s+(?P<measurements>.*?)\\s*$')
    measurement_re = re.compile(f'^(?P<image_idx>\\d+)\\s+(?P<feature_idx>\\d+)\\s+(?P<X>{num})\\s+(?P<Y>{num}).*')
    for i in range(int(total_points)):
        idx = 5 + int(total_cameras) + i
        match = marker_re.match(lines[idx])
        if not match:
            raise AttributeError(f'VisualSfM marker {i} did not match the format specification')
        trackers.setdefault(i, {'co': tuple(map(float, [match.group('X'), match.group('Y'), match.group('Z')])), 'rgb': tuple(map(int, [match.group('R'), match.group('G'), match.group('B')]))})
        cur = match.group('measurements')
        for m in range(int(match.group('num_measurements'))):
            measurement_match = measurement_re.match(cur)
            if not measurement_match:
                raise AttributeError(f'VisualSfM marker {i} did not match measurement {m} format specification')
            cameras[int(measurement_match.group('image_idx'))]['trackers'].setdefault(i, (float(measurement_match.group('X')), -1 * float(measurement_match.group('Y'))))
            cur = cur[measurement_match.end(len(measurement_match.groups())):].strip()
    return data
```
</details>
<!---Documatic-block-visualsfm.extract.extract-end--->
<!---Documatic-section-extract-end--->

# #
<!---Documatic-section-visualsfm.extract.extract-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)